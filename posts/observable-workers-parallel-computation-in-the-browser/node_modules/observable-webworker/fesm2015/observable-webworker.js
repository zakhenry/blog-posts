import { Notification, fromEvent, Observable, Subject, zip, of } from 'rxjs';
import { map, filter, dematerialize, concatMap, materialize, tap, mergeAll, finalize } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 * @template I, O
 * @param {?} worker
 * @return {?}
 */
function workerIsTransferableType(worker) {
    return !!worker.selectTransferables;
}
/**
 * \@internal
 * @template I, O
 * @param {?} worker
 * @return {?}
 */
function workerIsUnitType(worker) {
    return !!((/** @type {?} */ (worker))).workUnit;
}
/**
 * \@internal
 * @template I, O
 * @param {?} worker
 * @param {?} incomingMessages$
 * @return {?}
 */
function getWorkerResult(worker, incomingMessages$) {
    /** @type {?} */
    const input$ = incomingMessages$.pipe(map((/**
     * @param {?} e
     * @return {?}
     */
    (e) => e.data)), map((/**
     * @param {?} n
     * @return {?}
     */
    (n) => new Notification(n.kind, n.value, n.error))), 
    // ignore complete, the calling thread will manage termination of the stream
    filter((/**
     * @param {?} n
     * @return {?}
     */
    n => n.kind !== 'C')), dematerialize());
    return workerIsUnitType(worker)
        ? input$.pipe(concatMap((/**
         * @param {?} input
         * @return {?}
         */
        input => worker.workUnit(input).pipe(materialize()))))
        : worker.work(input$).pipe(materialize());
}
/**
 * @template I, O
 * @param {?} workerConstructor
 * @return {?}
 */
function runWorker(workerConstructor) {
    /** @type {?} */
    const worker = new workerConstructor();
    /** @type {?} */
    const incomingMessages$ = fromEvent(self, 'message');
    /** @type {?} */
    const transferableWorker = workerIsTransferableType(worker);
    return getWorkerResult(worker, incomingMessages$).subscribe((/**
     * @param {?} notification
     * @return {?}
     */
    (notification) => {
        // type to workaround typescript trying to compile as non-webworker context
        /** @type {?} */
        const workerPostMessage = (/** @type {?} */ (((/** @type {?} */ (postMessage)))));
        if (transferableWorker && notification.hasValue) {
            workerPostMessage(notification, worker.selectTransferables(notification.value));
        }
        else {
            workerPostMessage(notification);
        }
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function ObservableWorker() {
    return (/**
     * @template I, O
     * @param {?} workerConstructor
     * @return {?}
     */
    (workerConstructor) => {
        runWorker(workerConstructor);
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Input, Output
 * @param {?} workerFactory
 * @param {?} input$
 * @param {?=} selectTransferables
 * @param {?=} options
 * @return {?}
 */
function fromWorker(workerFactory, input$, selectTransferables, options = { terminateOnComplete: true }) {
    return new Observable((/**
     * @param {?} responseObserver
     * @return {?}
     */
    (responseObserver) => {
        /** @type {?} */
        let worker;
        /** @type {?} */
        let subscription;
        try {
            worker = workerFactory();
            worker.onmessage = (/**
             * @param {?} ev
             * @return {?}
             */
            (ev) => responseObserver.next(ev.data));
            worker.onerror = (/**
             * @param {?} ev
             * @return {?}
             */
            (ev) => responseObserver.error(ev));
            subscription = input$
                .pipe(materialize(), tap((/**
             * @param {?} input
             * @return {?}
             */
            input => {
                if (selectTransferables && input.hasValue) {
                    /** @type {?} */
                    const transferables = selectTransferables(input.value);
                    worker.postMessage(input, transferables);
                }
                else {
                    worker.postMessage(input);
                }
            })))
                .subscribe();
        }
        catch (error) {
            responseObserver.error(error);
        }
        return (/**
         * @return {?}
         */
        () => {
            if (subscription) {
                subscription.unsubscribe();
            }
            if (worker && options.terminateOnComplete) {
                worker.terminate();
            }
        });
    })).pipe(map((/**
     * @param {?} __0
     * @return {?}
     */
    ({ kind, value, error }) => new Notification(kind, value, error))), dematerialize());
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template I, O
 * @param {?} workerConstructor
 * @param {?} workUnitIterator
 * @param {?=} options
 * @return {?}
 */
function fromWorkerPool(workerConstructor, workUnitIterator, options) {
    const { 
    // tslint:disable-next-line:no-unnecessary-initializer
    selectTransferables = undefined, workerCount = navigator.hardwareConcurrency - 1, flattenOperator = mergeAll(), } = options || {};
    return new Observable((/**
     * @param {?} resultObserver
     * @return {?}
     */
    resultObserver => {
        /** @type {?} */
        const idleWorker$$ = new Subject();
        /** @type {?} */
        let completed = 0;
        /** @type {?} */
        let sent = 0;
        /** @type {?} */
        let finished = false;
        /** @type {?} */
        const lazyWorkers = Array.from({ length: workerCount }).map((/**
         * @param {?} _
         * @param {?} index
         * @return {?}
         */
        (_, index) => {
            return {
                _cachedWorker: null,
                /**
                 * @return {?}
                 */
                factory() {
                    if (!this._cachedWorker) {
                        this._cachedWorker = workerConstructor(index);
                        this.started = true;
                    }
                    return this._cachedWorker;
                },
                /**
                 * @return {?}
                 */
                terminate() {
                    if (this.started && !this.processing) {
                        this._cachedWorker.terminate();
                    }
                },
                processing: false,
                started: false,
                index,
            };
        }));
        /** @type {?} */
        const processor$ = zip(idleWorker$$, workUnitIterator).pipe(tap((/**
         * @param {?} __0
         * @return {?}
         */
        ([worker]) => {
            sent++;
            worker.processing = true;
        })), finalize((/**
         * @return {?}
         */
        () => {
            idleWorker$$.complete();
            finished = true;
            lazyWorkers.forEach((/**
             * @param {?} worker
             * @return {?}
             */
            worker => worker.terminate()));
        })), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([worker, unitWork]) => {
            return fromWorker((/**
             * @return {?}
             */
            () => worker.factory()), of(unitWork), selectTransferables, {
                terminateOnComplete: false,
            }).pipe(finalize((/**
             * @return {?}
             */
            () => {
                completed++;
                worker.processing = false;
                if (!finished) {
                    idleWorker$$.next(worker);
                }
                else {
                    worker.terminate();
                }
                if (finished && completed === sent) {
                    resultObserver.complete();
                }
            })));
        })), flattenOperator);
        /** @type {?} */
        const sub = processor$.subscribe(resultObserver);
        lazyWorkers.forEach((/**
         * @param {?} w
         * @return {?}
         */
        w => idleWorker$$.next(w)));
        return (/**
         * @return {?}
         */
        () => sub.unsubscribe());
    }));
}

export { ObservableWorker, fromWorker, fromWorkerPool, getWorkerResult, runWorker, workerIsTransferableType, workerIsUnitType };
//# sourceMappingURL=observable-webworker.js.map
