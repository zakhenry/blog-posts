import { Notification, fromEvent, Observable, Subject, zip, of } from 'rxjs';
import { map, filter, dematerialize, concatMap, materialize, tap, mergeAll, finalize } from 'rxjs/operators';
import { __read } from 'tslib';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 * @template I, O
 * @param {?} worker
 * @return {?}
 */
function workerIsTransferableType(worker) {
    return !!worker.selectTransferables;
}
/**
 * \@internal
 * @template I, O
 * @param {?} worker
 * @return {?}
 */
function workerIsUnitType(worker) {
    return !!((/** @type {?} */ (worker))).workUnit;
}
/**
 * \@internal
 * @template I, O
 * @param {?} worker
 * @param {?} incomingMessages$
 * @return {?}
 */
function getWorkerResult(worker, incomingMessages$) {
    /** @type {?} */
    var input$ = incomingMessages$.pipe(map((/**
     * @param {?} e
     * @return {?}
     */
    function (e) { return e.data; })), map((/**
     * @param {?} n
     * @return {?}
     */
    function (n) { return new Notification(n.kind, n.value, n.error); })), 
    // ignore complete, the calling thread will manage termination of the stream
    filter((/**
     * @param {?} n
     * @return {?}
     */
    function (n) { return n.kind !== 'C'; })), dematerialize());
    return workerIsUnitType(worker)
        ? input$.pipe(concatMap((/**
         * @param {?} input
         * @return {?}
         */
        function (input) { return worker.workUnit(input).pipe(materialize()); })))
        : worker.work(input$).pipe(materialize());
}
/**
 * @template I, O
 * @param {?} workerConstructor
 * @return {?}
 */
function runWorker(workerConstructor) {
    /** @type {?} */
    var worker = new workerConstructor();
    /** @type {?} */
    var incomingMessages$ = fromEvent(self, 'message');
    /** @type {?} */
    var transferableWorker = workerIsTransferableType(worker);
    return getWorkerResult(worker, incomingMessages$).subscribe((/**
     * @param {?} notification
     * @return {?}
     */
    function (notification) {
        // type to workaround typescript trying to compile as non-webworker context
        /** @type {?} */
        var workerPostMessage = (/** @type {?} */ (((/** @type {?} */ (postMessage)))));
        if (transferableWorker && notification.hasValue) {
            workerPostMessage(notification, worker.selectTransferables(notification.value));
        }
        else {
            workerPostMessage(notification);
        }
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function ObservableWorker() {
    return (/**
     * @template I, O
     * @param {?} workerConstructor
     * @return {?}
     */
    function (workerConstructor) {
        runWorker(workerConstructor);
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Input, Output
 * @param {?} workerFactory
 * @param {?} input$
 * @param {?=} selectTransferables
 * @param {?=} options
 * @return {?}
 */
function fromWorker(workerFactory, input$, selectTransferables, options) {
    if (options === void 0) { options = { terminateOnComplete: true }; }
    return new Observable((/**
     * @param {?} responseObserver
     * @return {?}
     */
    function (responseObserver) {
        /** @type {?} */
        var worker;
        /** @type {?} */
        var subscription;
        try {
            worker = workerFactory();
            worker.onmessage = (/**
             * @param {?} ev
             * @return {?}
             */
            function (ev) { return responseObserver.next(ev.data); });
            worker.onerror = (/**
             * @param {?} ev
             * @return {?}
             */
            function (ev) { return responseObserver.error(ev); });
            subscription = input$
                .pipe(materialize(), tap((/**
             * @param {?} input
             * @return {?}
             */
            function (input) {
                if (selectTransferables && input.hasValue) {
                    /** @type {?} */
                    var transferables = selectTransferables(input.value);
                    worker.postMessage(input, transferables);
                }
                else {
                    worker.postMessage(input);
                }
            })))
                .subscribe();
        }
        catch (error) {
            responseObserver.error(error);
        }
        return (/**
         * @return {?}
         */
        function () {
            if (subscription) {
                subscription.unsubscribe();
            }
            if (worker && options.terminateOnComplete) {
                worker.terminate();
            }
        });
    })).pipe(map((/**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var kind = _a.kind, value = _a.value, error = _a.error;
        return new Notification(kind, value, error);
    })), dematerialize());
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template I, O
 * @param {?} workerConstructor
 * @param {?} workUnitIterator
 * @param {?=} options
 * @return {?}
 */
function fromWorkerPool(workerConstructor, workUnitIterator, options) {
    var _a = options || {}, 
    // tslint:disable-next-line:no-unnecessary-initializer
    _b = _a.selectTransferables, 
    // tslint:disable-next-line:no-unnecessary-initializer
    selectTransferables = _b === void 0 ? undefined : _b, _c = _a.workerCount, workerCount = _c === void 0 ? navigator.hardwareConcurrency - 1 : _c, _d = _a.flattenOperator, flattenOperator = _d === void 0 ? mergeAll() : _d;
    return new Observable((/**
     * @param {?} resultObserver
     * @return {?}
     */
    function (resultObserver) {
        /** @type {?} */
        var idleWorker$$ = new Subject();
        /** @type {?} */
        var completed = 0;
        /** @type {?} */
        var sent = 0;
        /** @type {?} */
        var finished = false;
        /** @type {?} */
        var lazyWorkers = Array.from({ length: workerCount }).map((/**
         * @param {?} _
         * @param {?} index
         * @return {?}
         */
        function (_, index) {
            return {
                _cachedWorker: null,
                factory: /**
                 * @return {?}
                 */
                function () {
                    if (!this._cachedWorker) {
                        this._cachedWorker = workerConstructor(index);
                        this.started = true;
                    }
                    return this._cachedWorker;
                },
                terminate: /**
                 * @return {?}
                 */
                function () {
                    if (this.started && !this.processing) {
                        this._cachedWorker.terminate();
                    }
                },
                processing: false,
                started: false,
                index: index,
            };
        }));
        /** @type {?} */
        var processor$ = zip(idleWorker$$, workUnitIterator).pipe(tap((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var _b = __read(_a, 1), worker = _b[0];
            sent++;
            worker.processing = true;
        })), finalize((/**
         * @return {?}
         */
        function () {
            idleWorker$$.complete();
            finished = true;
            lazyWorkers.forEach((/**
             * @param {?} worker
             * @return {?}
             */
            function (worker) { return worker.terminate(); }));
        })), map((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var _b = __read(_a, 2), worker = _b[0], unitWork = _b[1];
            return fromWorker((/**
             * @return {?}
             */
            function () { return worker.factory(); }), of(unitWork), selectTransferables, {
                terminateOnComplete: false,
            }).pipe(finalize((/**
             * @return {?}
             */
            function () {
                completed++;
                worker.processing = false;
                if (!finished) {
                    idleWorker$$.next(worker);
                }
                else {
                    worker.terminate();
                }
                if (finished && completed === sent) {
                    resultObserver.complete();
                }
            })));
        })), flattenOperator);
        /** @type {?} */
        var sub = processor$.subscribe(resultObserver);
        lazyWorkers.forEach((/**
         * @param {?} w
         * @return {?}
         */
        function (w) { return idleWorker$$.next(w); }));
        return (/**
         * @return {?}
         */
        function () { return sub.unsubscribe(); });
    }));
}

export { ObservableWorker, fromWorker, fromWorkerPool, getWorkerResult, runWorker, workerIsTransferableType, workerIsUnitType };
//# sourceMappingURL=observable-webworker.js.map
